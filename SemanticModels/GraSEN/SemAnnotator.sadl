 // can I identify some of the constants missing in PID and PID-simplified that I was getting originally???
 
 // We do not identify "PI-Controller with saturation"
 // not properly handling PI inline
 // can I get qualified name for controller?
 // note in PI with typo, we identify a type and then say it is P-Controller; I could refine the rule

// TBD: test and refine as needed ig multiple controllers present in a file.

// ISSUES upstream
// 		in PI with ptr, integrator_state is being identified as a constant
// 		for RETURN_VAL, the json incorrectly says that it is from source; similarly for PID_realize_ARG_0

// Not what I can handle
// 		error_last does not have line begin; is it present in json file? once this is resolved then
//			need to check for "error_last = error" is present
//		not checking error_last = error as it does not seem to be present correctly in the input file
 
uri "http://sadl.org/SemAnnotator.sadl" alias semannotator.

import "http://www.w3.org/1999/02/22-rdf-syntax-ns".
import "http://grasen.ge.com/SemanticAnalysisModel.sadl". 

// Do we need the transitive rules, Transitive1 needs to be modified is needed?
// Rule Transitive1 
// if cls1 rdfs:subClassOf cls2
// and cls2 rdfs:subClassOf cls3
// then cls1 rdfs:subClassOf cls3.
 
 Rule Transitive2  
if inst is a cls
   and cls is a type of cls2
then inst is a cls2.

Stage 1 Rule varNameR
if 	    x is a Variable
	and x identifier id
	and xn is strafter(strbefore(strafter(strafter(id,"::"),"::"),"::"),"\\\\.")
then x varName xn.

Stage 1 Rule explicitVarR
if	    x is a Variable
	and from_source of metadata of x is true
then x is an ExplicitVariable.

Stage 1 Rule sameVarR
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block
	and x2 inBlock block
	and x1 != x2
	and varName of x1 == varName of x2
then x1 sameVar x2.

Stage 1 Rule sameVarR2
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block1
	and x2 inBlock block2
	and block2 parent block1
	and varName of x1 == varName of x2
then    x1 sameVar x2
	and x2 sameVar x1.
	
Stage 1 Rule sameVarInterfaceR
if 		x1 is a Variable
	and x2 is a Variable
	and edge function fun
	and fun ftype "INTERFACE"
	and edge inputs x1 //AM 11/13 moved it lower
	and edge outputs x2
	and x1 != x2
	and varName of x1 == varName of x2
then    x1 sameVar x2
    and x2 sameVar x1.	

Stage 1 Rule sameVarStructureR1
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "PACK"
	and e2 inputs x2
	and x1 != x2
	and varName of x1 == varName of x2
then x1 sameVar x2.

Stage 1 Rule sameVarStructureR2
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "EXTRACT"
	and e2 outputs x2
	and e1 outputs struct1 //AM 11/13 moved it lower	
	and e2 inputs struct2
	and varName of struct1 == varName of struct2
	and x1 != x2
	and varName of x1 == varName of x2
then    x1 sameVar x2
    and x2 sameVar x1.

Stage 1 Rule structureVariableR
if	edge function fun
	and fun ftype "PACK"
	and edge outputs var
then var is a Structure.

Stage 1 Rule loopBlockR
if	 node sg_type "LoopContainer"
then node is a LoopBlock.
	
Stage 1 Rule funcBlockR
if	 node sg_type "FuncContainer"
then node is a FunctionBlock.
	
Stage 1 Rule nestedBlockR
if		node is a SubGraph
	and node parent par
then node is a NestedBlock.
	
Stage 1 Rule varInBlockR
if		var is a Variable
	and b is a SubGraph
	and b nodes var
then var inBlock b.

Stage 3 Rule lineEndR //AM 11/13 could even make it Stage 4 but keeping it in Stage 3 avoids "backtracking" in rule ControllerMetadataR
if		x metadata md
	and noValue(md,line_end)
	and md line_begin lb
then md line_end lb.

Rule literalInitializedR1
if		edge function f
	and f ftype "LITERAL"
	and edge outputs var
	and var is an ExplicitVariable
then  var is a LiteralInitialized .

//Find parameter argument pairs.
Stage 1 Rule argParamPairR
if	edge is a HyperEdge
	and edge function fun
	and fun ftype "INTERFACE"
	and grph nodes fun
	and sg_type of grph != "LoopContainer"
	and edge inputList inList
	and edge outputList outList
	and arg is a Variable
	and param is a ExplicitVariable
	and _idx is index of arg in inList
	and _idx is index of param in outList
then
	there exists an ArgParamPair pair
	and edge argumentParameterPair pair
	and pair parameter param
	and pair argument arg
. 

Stage 1 Rule lhsR1 
if	 var is LiteralInitialized
then var is a LHS.

Stage 1 Rule lhsR2
if		edge is a HyperEdge
   	and edge outputs var
   	and var is an ExplicitVariable
   	and edge function fun
   	and fun ftype "ASSIGN"
then 
	var is a LHS.

//a parameter assigned an argument is also a LHS
Stage 1 Rule lhsR3
if	pair parameter param
	and pair argument arg
then
	param is a LHS.
	
Stage 1 Rule lhsR4 //LHS of function call 
if		edge is a HyperEdge
   	and edge outputs var  //   	and from_source of metadata of var is true //only look at explicit vars
   	and var is an ExplicitVariable
   	and edge function fun
   	and fun ftype "INTERFACE"
   	and edge inputs ret
   	and ret varName "RETURN_VAL"
then 
	var is a LHS.
	
Stage 1 Rule MultiplicationR
if	    nd is an ExpNode
	and nd operator "Mult"
	and nd children clist
	and mxx is an ExpNode
	and index of mxx in clist is idx
then    nd is a Multiplication
	and nd multiplicand mxx.

Stage 1 Rule SummationR
if	    nd is an ExpNode
	and nd operator "Add"
	and nd children clist
	and mxx is an ExpNode
	and index of mxx in clist is idx
then    nd is a Summation
	and nd summand mxx.

Stage 1 Rule SubtractionR
if	    nd is an ExpNode
	and nd operator "Sub"
	and nd children clist
	and m is element 0 of clist
	and s is element 1 of clist
then    nd is a Subtraction
	and nd minuend m
	and nd subtrahend s.

Stage 1 Rule notConstantR1
if		var1 is a LHS
	and var2 is a LHS 
	and var1 sameVar var2
	and edge inputs var1
	and edge outputs var2
	and edge function fun
then
	var1 is a NotConstant
	and var2 is a NotConstant.

Stage 1 Rule notConstantR2
if		var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a LoopBlock
then var is a NotConstant.

Stage 1 Rule notConstantR3
if	pair parameter param
	and pair argument arg
	and arg is a NotConstant
then
	param is a NotConstant.

Stage 1 Rule notConstantR4
if	var1 is an ExplicitVariable
	and var2 is a NotConstant
	and var1 sameVar var2
	and gph nodes var1
	and gph nodes var2
then
	var1 is a NotConstant.
	
Stage 1 Rule notConstantR5
if	edge function fun
	and edge inputs var1
	and edge outputs var2
	and var1 sameVar var2
	and grph nodes fun
	and grph sg_type "LoopContainer"
	and var2 is a NotConstant
then
	var1 is a NotConstant.	
	
Stage 1 Rule notConstantR6
if		edge function f
	and f ftype "ASSIGN"
	and edge outputs var
	and var is an ExplicitVariable
	and edge inputs varI
	and varI is a NotConstant
then
	var is a NotConstant.
	
Stage 2 Rule constantR
if		var is a ExplicitVariable
	and var is not a NotConstant
then var is a Constant.

// this still uses element 0 etc., can we re-write it?
Stage 2 Rule ErrorSignalR
if 		fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2 
	and edge outputs var
	and var is a NotConstant  //AM 11/13 added
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and rs is a Constant  //AM 11/13 added
	and ms is a NotConstant  //AM 11/13 added
	and ms_et grfn_uid ms
    and fun lambda expr0
    and expr is strafter(expr0,":")
then    var is an ErrorSignal
	and rs is a ReferenceSignal 
	and ms is a MeasurementSignal
	and var referenceSignal rs  
	and var measurementSignal ms
	and var semanticExpression expr.

Stage 2 Rule DerivativeR
if 		fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2 
	and edge outputs var
	and var is a NotConstant  //AM 11/13 added
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and rs is a ErrorSignal  //AM 11/13 added
	and ms is a NotConstant  //AM 11/13 added
	and ms_et grfn_uid ms
    and fun lambda expr0
    and expr is strafter(expr0,":")
then    var is an Derivative
	and ms is a PrevError.
	
Stage 2 Rule IntegratorR1
if      x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out is a NotConstant  //AM 11/13 added
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
    and n1 is a Summation // one child should be Mult and one should be what is in LHS in our example
	and n1 summand c1
	and n1 summand c2
    and c2 var_name out_name // so LHS is repeated in the RHS    
    and c1 is a Multiplication
    and c1 multiplicand cc2   
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS
then out is an Integrator.   

// no multiplier
Stage 2 Rule IntegratorR2 // make it more robust
if      x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out is NotConstant  //AM 11/13 added
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
    and n1 is a Summation // one child should be Mult and one should be what is in LHS in our example
	and n1 summand c1
	and n1 summand c2
    and c2 var_name out_name // so LHS is repeated in the RHS    
    and x varName error_signal_name
    and c1 var_name error_signal_name  // so ErrorSignal present in RHS
then out is an Integrator.    

// This rule is still dependent on a particular order in the subtraction
Stage 2 Rule IntegratorTypoR
if      x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out is a NotConstant  //AM 11/13 added
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
	and n1 is a Subtraction
	and n1 minuend c2
	and n1 subtrahend c1 
    and c2 var_name out_name // so LHS is repeated in the RHS    
    and c1 is a Multiplication
    and c1 multiplicand cc2    
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS
then out is an IntegratorTypo.    

Stage 3 Rule PropExpNodeR // incorrectly matches with "timestep * error" and identifies timestep as proportional constant
if      m is a Multiplication
	and m multiplicand err_var
	and err_var grfn_uid err
	and err is an ErrorSignal
	and m multiplicand kp_var
	and kp_var grfn_uid kp_cand
	and kp is a Constant
	and kp is not an ErrorSignal //hence this is Stage 3
	and varName of kp == varName of kp_cand
	and err != kp // I THINK I NEED TO SAY varName NOT SAME!!!!!!!!!!
then    m is a PropExpNode //ConstTimesError
    and m proportionalConstant kp //kp_cand
    and m errorVariable err
//     and kp_cand is a ProportionalConstant //once we line up parameters and arguments, kp_cand should replace kp here
    and kp is a ProportionalConstant.

Stage 3 Rule IntExpNodeR // matches constant * integrator value
if      m is a Multiplication
	and m multiplicand int_var
	and int_var grfn_uid int_cand
	and int_cand is an Integrator
	and m multiplicand ki_var
	and ki_var grfn_uid ki_cand
	and ki is a Constant
	and varName of ki == varName of ki_cand
	and varName of int_cand != varName of ki
then     m is a IntExpNode 
    and m integratorConstant ki 
    and ki is a IntegratorConstant
    and m integratorVariable int_cand.

Stage 3 Rule DervExpNodeR
if      m is a Multiplication
	and m multiplicand derv_var
	and derv_var grfn_uid derv_cand
	and derv_cand is an Derivative
	and m multiplicand kd_var
	and kd_var grfn_uid kd_cand
	and kd is a Constant
	and varName of kd == varName of kd_cand
	and varName of derv_cand != varName of kd
then    m is a DervExpNode 
    and m derivativeConstant kd //ki_cand
//     and ki_cand is a IntegratorConstant //once we line up parameters and arguments, ki_cand should replace ki
    and kd is a DerivativeConstant
    and m derivativeVariable derv_cand.
	
Stage 4 Rule ControllerNameR
if 	    sg nodes exp
	and exp is a Controller
	and sg is a SubGraph
 	and sg nodes somenode
 	and somenode identifier id	
 	and exp_name is strbefore(strafter(id,"::"),"::")
 then exp constructName exp_name. 	

Stage 4 Rule ControllerMetadataR
if 	sg is a SubGraph
	and sg nodes pic
	and pic is a Controller
	and sg metadata md
 	and md line_begin lbeg
 	and md line_end lend
then    pic linebegin lbeg
	and pic lineend lend.

Stage 3 Rule P-ControllerCandidateR
if  	et is an ExpressionTree
	and et nodes exp
	and exp is a PropExpNode
	and exp is a Multiplication 
	and exp multiplicand m1
	and exp multiplicand m2
then et is a P-ControllerCandidate.

Stage 3 Rule PI-ControllerCandidateR
if  	et is a P-ControllerCandidate
	and et nodes exp
	and exp is a Summation 
	and exp summand m1
//	and m1 proportionalConstant kp //AM 11/13 no need to check
	and m1 is a PropExpNode 
	and exp summand m2
	and m2 is a IntExpNode 
//	and m2 integratorConstant ki //AM 11/13 no need to check
then et is a PI-ControllerCandidate.

Stage 3 Rule PD-ControllerCandidateR
if 		et is a P-ControllerCandidate
	and et nodes exp
	and exp is a Summation 
	and exp summand m1
	and m1 is a PropExpNode
//	and m1 proportionalConstant kp //AM 11/13 no need to check
	and exp summand m2
	and m2 is a DervExpNode
//	and m2 derivativeConstant kd //AM 11/13 no need to check
then et is a PD-ControllerCandidate.

Stage 3 Rule PID-ControllerR
if     et is an PI-ControllerCandidate
   and et nodes n1
   and n1 is a DervExpNode
then et is a PID-Controller.

Stage 4 Rule P-ControllerR
if		et is a P-ControllerCandidate
	and noValue(et1,rdf:type,PI-ControllerCandidate)
	and noValue(et1,rdf:type,PD-ControllerCandidate)
	and noValue(et1,rdf:type,PID-Controller)
then
	et is a P-Controller.

Stage 4 Rule PI-ControllerR
if	et is a PI-ControllerCandidate
	and noValue(et1,rdf:type,PID-Controller)
then
	et is a PI-Controller.

Stage 4 Rule PD-ControllerR
if	et is a PD-ControllerCandidate
	and noValue(et1,rdf:type,PID-Controller)
then
	et is a PD-Controller.
