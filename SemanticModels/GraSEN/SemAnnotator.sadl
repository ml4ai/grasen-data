 uri "http://sadl.org/SemAnnotator.sadl" alias semannotator.
 
// select the C code file for processing
//import "http://sadl.org/PID.sadl".
import "http://sadl.org/GE_simple_PI_controller.sadl".

ControllerConstruct is a class. 

LoopBlock is a type of SubGraph.
FunctionBlock is a type of SubGraph.
LHS (note "a var that appears on the LHS of an assignment") is a type of Variable.

sameVar describes Variable with values of type Variable.
varName describes Variable with values of type string.
inBlock describes Variable with values of type SubGraph.
LiteralInitialized is a type of Variable.
NotConstant is a type of Variable.
Constant is a type of Variable. 
ExplicitVariable is a type of Variable.

ErrorSignal is a type of Variable
	described by referenceSignal with a single value of type ReferenceSignal
	described by measurementSignal with a single value of type MeasurementSignal.
ReferenceSignal is a type of Variable.
MeasurementSignal is a type of Variable.

semanticExpression describes Variable with a single value of type string.

ErrorSignal is a type of ControllerConstruct.
ReferenceSignal is a type of ControllerConstruct.
MeasurementSignal is a type of ControllerConstruct.


Rule instanceOfSubclassR
if	x is a SubClass
	and SubClass is a type of SuperClass
then
	x is a SuperClass.

Rule varNameR
if 		x is a Variable
	and x identifier id
	and xn is strafter(strbefore(strafter(strafter(id,"::"),"::"),"::"),"\\\\.")
then
	x varName xn.


Rule explicitVarR
if	x is a Variable
	and line_begin of metadata of x is lb
then
	x is an ExplicitVariable.

//Ask: select distinct vn where x is an ExplicitVariable and x varName vn.

Rule sameVarR
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block
	and x2 inBlock block
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2.
	
Rule sameVarInterfaceR
if 		x1 is a Variable
	and x2 is a Variable
	and edge inputs x1
	and edge outputs x2
	and edge function fun
	and fun ftype "INTERFACE"
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2
and x2 sameVar x1.	

Rule sameVarStructureR
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "PACK"
	and e2 inputs x2
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2.

//Ask: select id1 id2 where var1 sameVar var2 and var1 identifier id1 and var2 identifier id2.


Rule loopBlockR
if	node sg_type "LoopContainer"
then node is a LoopBlock.
	
Rule funcBlockR
if	node sg_type "FuncContainer"
then node is a FunctionBlock.
	
Rule varInBlockR
if	var is a Variable
	and b is a SubGraph
	and b nodes var
then
	var inBlock b.
	
//Ask: select distinct vn bt where var inBlock b and var varName vn and b sg_type bt.


Rule lhsR 
if 	edge is a HyperEdge
   	and edge outputs var
   	and edge function fun
   	and ftype of fun != "INTERFACE"
then 
	var is a LHS.
	
//Ask: select vn vid where var is a LHS and var varName vn and var identifier vid.
	
Rule literalInitializedR
if edge function f
   and f ftype "LITERAL"
   and edge outputs var
then 
	var is a LiteralInitialized .
	
//Ask: select vn where var varName vn and var is a LiteralInitialized.


Rule notConstantR1
if	var1 is a LHS
	and var2 is a LHS
	and var1 sameVar var2
then
	var1 is a NotConstant.

//Comment out if not using---negation slows things down
Stage 2 Rule notConstantR2
if	var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a LoopBlock
then
	var is a NotConstant.

//Ask: select vid vn where
//	var is a LHS
//	and var inBlock block
//	and block is a LoopBlock
//	and var varName vn
//	and var identifier vid
//	and var is not a LiteralInitialized
//	.


Stage 3 Rule notConstantR3
if	var1 is a NotConstant
	and var1 sameVar var2
then
	var2 is a NotConstant.

//Ask: select distinct vn vid where var is a NotConstant and var varName vn and var identifier vid.

//Ask: select distinct vn vid where var is a Variable and var varName vn and var identifier vid and var is not a NotConstant.

Stage 4 Rule constantR
if	var is a LHS
	and var is not a NotConstant
then
	var is a Constant.


//Ask: select distinct vn vid where var is a Variable and var varName vn and var identifier vid and var is a Constant . 
//Ask: select distinct vn vid where var is a Variable and var varName vn and var identifier vid and var is a NotConstant.

//Ask: select distinct vn where var is a Variable and var varName vn and var identifier vid and var is a Constant.

	
Rule ErrorSignalCandidate
if 	fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and 2 is length of clist          //this may not be sufficient--if subtract nested expressions, Sub may still have only two children
	and edge function fun  
	and edge outputs var
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and ms_et grfn_uid ms
	and fun lambda expr
then
	var is an ErrorSignal
	and rs is a ReferenceSignal 
	and ms is a MeasurementSignal
	and var referenceSignal rs
	and var measurementSignal ms
	and var semanticExpression expr
.

Rule lineEndR
if	x metadata md
	and noValue(md,line_end)
	and md line_begin lb
then
	md line_end lb.

//Ask: select vname vtype loc_start loc_end qual_name 
//where
//	vtype is a type of ControllerConstruct
//	and x is a vtype
//	and x varName vname
//	and x identifier qual_name
//	and loc_start is line_begin of metadata of x
//	and loc_end is line_begin of metadata of x
//.

Ask: "select ?name ?annotationType ?loc_start ?loc_end ?qual_name ?expr
where {
  ?annotationType <rdfs:subClassOf> <ControllerConstruct> .
  ?x <rdf:type> ?annotationType .
  ?x <varName> ?name .
  ?x <identifier> ?qual_name .
  ?x <metadata> ?md .
  ?md <line_begin> ?loc_start .
  ?md <line_end> ?loc_end.
  optional {?x <semanticExpression> ?expr}
}".


//Ask: "select ?name ?annotationType ?loc_start ?loc_end ?qual_name 
//where {
//  ?x <semanticallyAnnotated> true
//. ?x <semanticAnnotationType> ?annotationType 
//. ?x <varName> ?name
//. ?x <identifier> ?qual_name
//. ?x <metadata> ?md 
//. ?md <line_begin> ?loc_start
//. LET(?loc_end := ?loc_start)
//. OPTIONAL{?md <line_end> ?loc_end}
//}".

//Ask: select esn rsn msn lexpr
//where 
//es is a ErrorSignal 
//and es referenceSignal rs
//and es measurementSignal ms
//and es varName esn
//and rs varName rsn
//and ms varName msn 
//and es semanticExpression lexpr
//.