 uri "http://sadl.org/SemAnnotator.sadl" alias semannotator.
 
import "http://sadl.org/GrFNExtractionModel.sadl" as grfnem.
 
// select the C code file for processing
import "http://aske.ge.com/GE_simple_PI_controller_combined".
//import "http://aske.ge.com/GE_simple_PI_controller_inline".

//import "http://aske.ge.com/PID".
//import "http://aske.ge.com/GE_simple_PI_controller_saturation".

ControllerConstruct is a class
	described by constructName with values of type string
	described by linebegin with values of type int
	described by lineend with values of type int
	. 

LoopBlock is a type of SubGraph.
FunctionBlock is a type of SubGraph.
NestedBlock is a type of SubGraph.
LHS (note "a var that appears on the LHS of an assignment") is a type of Variable.

sameVar describes Variable with values of type Variable.
varName describes Variable with values of type string.
inBlock describes Variable with values of type SubGraph.
LiteralInitialized is a type of Variable.
NotConstant is a type of Variable.
Constant is a type of Variable. 
ExplicitVariable is a type of Variable.

ErrorSignal is a type of Variable
	described by referenceSignal with a single value of type ReferenceSignal
	described by measurementSignal with a single value of type MeasurementSignal.
ReferenceSignal is a type of Variable.
MeasurementSignal is a type of Variable.

Increment is a type of Variable. // the only assignment to it is of the form x = x +/-/* y
Counter is a type of Variable. // It is an Increment where y is a constant value or a literal
Accumulator is a type of Variable. // It is an Increment where y is not a constant or a literal
Integrator is a type of Variable. // It is an Accumulator where y is proportional to (ref signal - measured signal)
PI-Controller is a type of Node //Do I want it as node??????
	described by 
semanticExpression describes Variable with a single value of type string.

Constant is a type of ControllerConstruct.
description of Constant is "This is a constant.".
ErrorSignal is a type of ControllerConstruct.
description of ErrorSignal is "This is an error signal candidate.".
ReferenceSignal is a type of ControllerConstruct.
description of ReferenceSignal is "This is a reference signal candidate.".
MeasurementSignal is a type of ControllerConstruct.
description of MeasurementSignal is "This is a measurement signal candidate.".
Integrator is a type of ControllerConstruct.
description of Integrator is "This is an Integrator.".
IntegratorConstant is a type of Constant.
description of IntegratorConstant is "This is the constant multiplier for the Integrator.".
ProportionalConstant is a type of Constant.
description of ProportionalConstant is "This is the constant multiplier for the Proportional term.".
PI-Controller is a type of ControllerConstruct.
description of PI-Controller is "This is a PI Controller.".

multiplication describes ExpressionTree with values of type ExpNode.


//Stage 6 Rule instanceOfSubclassR
//if		x is a SubClass
//	and SubClass is a type of SuperClass
//then
//	x is a SuperClass.

Rule varNameR
if 		x is a Variable
	and x identifier id
	and xn is strafter(strbefore(strafter(strafter(id,"::"),"::"),"::"),"\\\\.")
then
	x varName xn.


Rule explicitVarR
if		x is a Variable
	and from_source of metadata of x is true
then
	x is an ExplicitVariable.

//Ask: select distinct vn where x is an ExplicitVariable and x varName vn.

Rule sameVarR
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block
	and x2 inBlock block
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2.
	
Rule sameVarInterfaceR
if 		x1 is a Variable
	and x2 is a Variable
	and edge inputs x1
	and edge outputs x2
	and edge function fun
	and fun ftype "INTERFACE"
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2
and x2 sameVar x1.	

Rule sameVarStructureR
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "PACK"
	and e2 inputs x2
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2.

//Ask: select id1 id2 where var1 sameVar var2 and var1 identifier id1 and var2 identifier id2.


Rule loopBlockR
if	 node sg_type "LoopContainer"
then node is a LoopBlock.
	
Rule funcBlockR
if	 node sg_type "FuncContainer"
then node is a FunctionBlock.
	
Rule nestedBlockR
if		node is a SubGraph
	and node parent par
then 
	node is a NestedBlock.
	
Rule varInBlockR
if		var is a Variable
	and b is a SubGraph
	and b nodes var
then
	var inBlock b.
	
//Ask: select distinct vn bt where var inBlock b and var varName vn and b sg_type bt.

Rule lineEndR
if		x metadata md
	and noValue(md,line_end)
	and md line_begin lb
then
	md line_end lb.


Rule lhsR 
if		edge is a HyperEdge
   	and edge outputs var
   	and from_source of metadata of var is true //only look at explicit vars
   	and edge function fun
   	and ftype of fun != "INTERFACE"
then 
	var is a LHS.
	
//Ask: select vn vid where var is a LHS and var varName vn and var identifier vid.
	
Rule literalInitializedR
if		edge function f
	and f ftype "LITERAL"
	and edge outputs var
then 
	var is a LiteralInitialized .
	
//Ask: select vn where var varName vn and var is a LiteralInitialized.


Stage 1 Rule notConstantR1
if		var1 is a LHS
	and var2 is a LHS
	and var1 sameVar var2
then
	var1 is a NotConstant.

//Comment out if not using---negation slows things down
Stage 1 Rule notConstantR2
if		var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a LoopBlock
then
	var is a NotConstant.

Stage 1 Rule notConstantR2A
if		var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a NestedBlock
then
	var is a NotConstant.

//Ask: select var vname
//where
//	var is a LHS
//	and var inBlock block
//	and block is a NestedBlock
//	and var varName vname
//	and var is not a LiteralInitialized 
//.

Stage 2 Rule notConstantR3
if		var1 is a NotConstant
	and var1 sameVar var2
	and var2 is an ExplicitVariable
then
	var2 is a NotConstant.

//Ask: select distinct vn vid where var is a NotConstant and var varName vn and var identifier vid.

//Ask: select distinct vn vid where var is a Variable and var varName vn and var identifier vid and var is not a NotConstant.

Stage 3 Rule constantR
if		var is a LHS
	and var is a ExplicitVariable
	and var is not a NotConstant
then
	var is a Constant.

// We may need this for future rules (not queries). It generates more constants.
//Stage 4 Rule constantR2
//if	var1 is a LHS
//	and var1 is not a NotConstant
//	and var1 sameVar var2
//then
//	var2 is a Constant.


//Ask: select distinct var vn vid where var is a Constant and var varName vn and var identifier vid . 

//Ask: select distinct var vn vid where var is a ExplicitVariable and var varName vn and var identifier vid and var is a Constant . 
//Ask: select distinct vn vid where var is a ExplicitVariable and var varName vn and var identifier vid and var is a NotConstant.

//Ask: select distinct vn where var is a Variable and var varName vn and var identifier vid and var is a Constant.

Rule ErrorSignalCandidate
if 		fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2 
	and edge outputs var
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and ms_et grfn_uid ms
    and fun lambda expr0
    and expr is strafter(expr0,":")
then
		var is an ErrorSignal
	and rs is a ReferenceSignal 
	and ms is a MeasurementSignal
	and var referenceSignal rs
	and var measurementSignal ms
	and var semanticExpression expr
.

//Doesn't work because edge has many inputs/outputs for complex expression
Rule ReferenceSignalCandidate  // works if the error computation is inlined
if 	fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and ms_et grfn_uid ms 
then rs is a ReferenceSignal 
	and ms is a MeasurementSignal
.

Stage 2 Rule IntegratorCandidate
if  x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
//    and he inputs in2
//    and in1 != in2
//    and in2 is a ErrorSignal
//    and in2 varName in2_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
    and n1 operator "Add" // one child should be Mult and one should be what is in LHS in our example
    and n1 children clist2
    and c1 is element 0 of clist2 // c1 and c2 do not have varName but have var_name
    and c2 is element 1 of clist2
    and c2 var_name out_name // so LHS is repeated in the RHS
    
//    and countMatches(clist2, ) how do I iterate over the elements of a list, is there "member" or something?
    
    and c1 operator "Mult" // now check for ErrorSignal in rest of the RHS
    and c1 children clist3
    and cc2 is element 1 of clist3
    
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS

then //print("x on both sides of = ", out_name) and
     out is an Integrator.    

//Ask: select var vname
//where
// var is an Integrator
// and var varName vname.


Stage 1 Rule Multiplications
if	
    exp is an ExpressionTree
    and exp nodes return_node
    and return_node operator "RETURN"
    and return_node children clist1
    and c1 is element 0 of clist1
    and c1 operator "Add"
    and c1 children clist2
    and d1 is element 0 of clist2
    and d2 is element 1 of clist2
    and d1 operator "Mult" 
    and d2 operator "Mult"
then
		exp multiplication d1
	and exp multiplication d2
.

//Ask: select d1
//where
//	exp multiplicand d1
//.

ConstTimesError is a type of ExpNode.
proportionalConstant describes ExpNode with values of type Constant.

Stage 4 Rule ConstTimesErrorR
if  
	exp multiplication d1
    and d1 children clist3 // has 2 children
    and err_cand is element 0 of clist3 
	and err_cand grfn_uid err
	and err is an ErrorSignal
    and kp_cand is element 1 of clist3
	and kp is a Constant
	and varName of kp == var_name of kp_cand
then 
     d1 is a ConstTimesError
     and d1 proportionalConstant kp
     and kp is a ProportionalConstant
.


ConstTimesIntegrator is a type of ExpNode.
integratorConstant describes ExpNode with values of type Constant.

Stage 4 Rule ConstTimesIntegratorR
if  
	exp multiplication d1
    and d1 children clist3 // has 2 children
    and f1 is element 0 of clist3 
	and f1 grfn_uid err
	and ki is a Constant
	and varName of ki == var_name of f1
    and f2 is element 1 of clist3
    and f2 grfn_uid integrator
    and integrator is an Integrator
then 
     d1 is a ConstTimesIntegrator 
     and d1 integratorConstant ki
     and ki is a IntegratorConstant
.

//Ask: select  var kp
//where 
// var is a ConstTimesIntegrator
// and var integratorConstant kp 
//.

Stage 5 Rule PI-ControllerCandidate
if  	exp multiplication d1
	and exp multiplication d2
	and d1 is a ConstTimesError
	and d1 proportionalConstant kp
	and d2 is a ConstTimesIntegrator
	and d2 integratorConstant ki
then
    exp is a PI-Controller // instead of exp have the entire module
	and exp proportionalConstant kp
	and exp integratorConstant ki
.

Stage 5 Rule PI-ControllerName
if 	sg nodes exp
	and exp is a PI-Controller
	and sg is a SubGraph
 	and sg nodes somenode
 	and somenode identifier id	
 	and exp_name is strbefore(strafter(id,"::"),"::")
 then
 	exp constructName exp_name
. 	

//Stage 5 Rule PI-ControllerMetadata
//if 	sg is a SubGraph
//	and sg nodes pic
//	and pic is a PI-Controller
//	and sg metadata md
// 	and md line_begin lbeg
// 	and md line_end lend
//then 
//	there exists a Metadata picmetadata
//	and pic has metadata picmetadata
//	and picmetadata has line_begin lbeg
//	and picmetadata has line_end lend
//.

Stage 5 Rule PI-ControllerMetadata
if 	sg is a SubGraph
	and sg nodes pic
	and pic is a PI-Controller
	and sg metadata md
 	and md line_begin lbeg
 	and md line_end lend
then 
	pic linebegin lbeg
	and pic lineend lend
.


//Ask: select md lbeg lend
//where
//	sg is a SubGraph
//	and sg nodes pic
//	and pic is a PI-Controller
//	and sg metadata md
// 	and md line_begin lbeg
// 	and md line_end lend
//.
//Ask: select distinct p pmd beg end
//where
//	p is a PI-Controller
//	and p constructName pname
//	and p metadata pmd
//	and pmd line_begin beg
//	and pmd line_end end
////	and p linebegin beg
////	and p lineend end
//	.


//	and exp proportionalConstant kp 
//	and kp varName propConst
//	and exp integratorConstant ki
//	and ki varName integrConst
// 	and exp lambda equation 


//Ask: select distinct id sg //propConst integrConst equation  
//where 
//	sg is a SubGraph
//	and sg nodes exp
// 	and exp is a PI-Controller
// 	and sg nodes somenode
// 	and somenode identifier id
//.

Write: data{
Ask: "select distinct ?Name ?AnnotationType ?Description ?Loc_start ?Loc_end ?Qual_name ?Equation    
where {
{  ?AnnotationType <rdfs:subClassOf>* <ControllerConstruct>
. ?x a ?AnnotationType 
.  filter not exists {
       ?C <rdfs:subClassOf> ?AnnotationType.
       ?x a ?C.
     }
. ?x <varName> ?Name
. ?AnnotationType <description> ?Description
. ?x <identifier> ?Qual_name
. ?x <metadata> ?md
. OPTIONAL{?md <line_begin> ?Loc_start} 
. OPTIONAL{?md <line_end> ?Loc_end}
. OPTIONAL{?x <semanticExpression> ?Equation} 
} union {
 ?x a <PI-Controller>
. ?x a ?AnnotationType
. ?AnnotationType <rdfs:subClassOf> <ControllerConstruct>
. ?x <constructName> ?Name
. OPTIONAL{?x <linebegin> ?Loc_start.}
. OPTIONAL{?x <lineend> ?Loc_end.}
. OPTIONAL{?AnnotationType <description> ?Description}
. OPTIONAL{?x <lambda> ?Equation} 
}
} order by ?AnnotationType ?Name".     
}to "SemAnnotation.csv".

//Write: data{
//Ask: "select distinct ?Name ?AnnotationType ?Description ?Loc_start ?Loc_end ?Qual_name ?Equation    
//where {
//{  ?AnnotationType <rdfs:subClassOf>* <ControllerConstruct>
//. ?x a ?AnnotationType 
//.  filter not exists {
//       ?C <rdfs:subClassOf> ?AnnotationType.
//       ?x a ?C.
//     }
//. ?x <varName> ?Name
//. ?AnnotationType <description> ?Description
//. ?x <identifier> ?Qual_name
//. ?x <metadata> ?md
//. OPTIONAL{?md <line_begin> ?Loc_start} 
//. OPTIONAL{?md <line_end> ?Loc_end}
//. OPTIONAL{?x <semanticExpression> ?Equation} 
//} union {
// ?x a <PI-Controller>
//. ?x a ?AnnotationType
//. ?AnnotationType <rdfs:subClassOf> <ControllerConstruct>
//. ?x <constructName> ?Name
//. OPTIONAL{?x <metadata> ?md. ?md <line_begin> ?Loc_start.}
//. OPTIONAL{?x <metadata> ?md. ?md <line_end> ?Loc_end.}
//. OPTIONAL{?AnnotationType <description> ?Description}
//. OPTIONAL{?x <lambda> ?Equation} 
//}
//} order by ?AnnotationType ?Name".     
//}to "SemAnnotation.csv".



//Stage 2 Rule PI-ControllerCandidate
//if  
//    exp is an ExpressionTree
//    and exp nodes return_node
//    and return_node operator "RETURN"
//    and return_node children clist1
//    and c1 is element 0 of clist1
//    and c1 operator "Add"
//    and c1 children clist2
//    and d1 is element 0 of clist2
//    and d2 is element 1 of clist2
//    and d1 operator "Mult" 
//    and d2 operator "Mult"
//    and d1 children clist3 // has 2 children
//    and err_cand is element 0 of clist3 
//	and err_cand grfn_uid err
//////	and err is an ErrorSignal
//    and kp_cand is element 1 of clist3
//////	and kp is a Constant
//////	and varName of kp == var_name of kp_cand
//         
//    and d2 children clist4
//    and f1 is element 0 of clist4
//    and f1 var_name f1n
////    and ki is an ExplicitVariable
////    and ki varName kin
////    and kin == f1n
//////    and ki is a Constant
////
////    and f2 is element 1 of clist4
////    and f2 grfn_uid integrator
//////    and integrator is an Integrator
//    
////    and f1 var_name f1_name
////    and f2 var_name f2_name
//then print(err_cand, f1) and 
//     exp is a PI-Controller // instead of exp have the entire module
////     and kp is a ProportionalConstant
////     and f1 is an IntegratorConstant
//.

 
//Ask: "select distinct ?AnnotationType ?Name ?Description ?Loc_start ?Loc_end ?Qual_name ?Equation  
//where {
//  ?AnnotationType <rdfs:subClassOf>* <ControllerConstruct> 
//. ?x a ?AnnotationType 
//.  filter not exists {
//       ?C <rdfs:subClassOf> ?AnnotationType.
//       ?x a ?C.
//     }
//. ?x <varName> ?Name
//. ?AnnotationType <description> ?Description
//. ?x <identifier> ?Qual_name
//. ?x <metadata> ?md
//. OPTIONAL{?md <line_begin> ?Loc_start} 
//. OPTIONAL{?md <line_end> ?Loc_end}
//. OPTIONAL{?x <semanticExpression> ?Equation} 
//} ".


//Write: data 
//{
//Ask: "select ?Name ?AnnotationType ?Description ?Loc_start ?Loc_end ?Qual_name ?Equation  
//where {
//  ?AnnotationType <rdfs:subClassOf> <ControllerConstruct>
//. ?x ?y ?AnnotationType . FILTER(regex(str(?y),'type'))
//. ?x a <ExplicitVariable>
//. ?x <varName> ?Name
//. ?AnnotationType <description> ?Description
//. ?x <identifier> ?Qual_name
//. ?x <metadata> ?md
//. optional{?md <line_begin> ?Loc_start} 
//. optional{?md <line_end> ?Loc_end}
//. OPTIONAL{?x <semanticExpression> ?Equation}
//} order by ?AnnotationType ?Name".
//} to "SemAnnotation.csv".


//Ask: select esn rsn msn lexpr
//where 
//es is a ErrorSignal 
//and es referenceSignal rs
//and es measurementSignal ms
//and es varName esn
//and rs varName rsn
//and ms varName msn 
//and es semanticExpression lexpr
//.