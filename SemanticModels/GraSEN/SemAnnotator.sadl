 // can I identify some of the constants missing in PID and PID-simplified that I was getting originally???
 
 // We do not identify "PI-Controller with saturation"
 // not properly handling PI inline
 // can I get qualified name for controller?
 // note in PI with typo, we identify a type and then say it is P-Controller; I could refine the rule

// TBD: test and refine as needed ig multiple controllers present in a file.

// ISSUES upstream
// 		in PI with ptr, integrator_state is being identified as a constant
// 		for RETURN_VAL, the json incorrectly says that it is from source; similarly for PID_realize_ARG_0

// Not what I can handle
// 		error_last does not have line begin; is it present in json file? once this is resolved then
//			need to check for "error_last = error" is present
//		not checking error_last = error as it does not seem to be present correctly in the input file
 
uri "http://sadl.org/SemAnnotator.sadl" alias semannotator.

import "http://www.w3.org/1999/02/22-rdf-syntax-ns".
import "http://grasen.ge.com/SemanticAnalysisModel.sadl". 
import "http://www.w3.org/2002/07/owl" as owl.
 
// select the C code file for processing

// PI controller and its variants
//import "http://aske.ge.com/GE_simple_PI_controller_combined".  //1
//import "http://aske.ge.com/GE_simple_PI_controller_saturation_combined". //4
//import "http://aske.ge.com/GE_simple_PI_controller-with-typo_combined". //5
//import "http://aske.ge.com/GE_simple_PI_controller_withptr_combined". //6
//import "http://aske.ge.com/GE_simple_PI_controller_inline_combined". // need to refine / add rules //7

//import "http://aske.ge.com/GE_simple_PID_controller_combined". //2
//import "http://aske.ge.com/GE_simple_P_controller_combined". //3
//import "http://aske.ge.com/GE_simple_PD_controller_combined". //10

//import "http://aske.ge.com/PID_combined". //8
//import "http://aske.ge.com/PID-Simplified_combined". //9


 Rule subConjunctionR
 if conj owl:intersectionOf l
  and conj1 owl:intersectionOf l1
  and l1 rdf:first conj
then
	conj is a SubConjunction.

Rule conjunctR1:
if conj owl:intersectionOf l
   and l rdf:first cls1
   and noValue(cls1,owl:intersectionOf)
then
   cls1 conjunctOf conj.

Rule conjunctR2:
if conj owl:intersectionOf l
   and l rdf:rest l1
   and l1 rdf:first cls2
   and noValue(cls2,owl:intersectionOf)
then
 cls2 conjunctOf conj . 

Rule conjunctR3:
if conj owl:intersectionOf l
   and l rdf:first conj2
   and cls1 conjunctOf conj2
   and cls2 conjunctOf conj2
then
   cls1 conjunctOf conj
and cls2 conjunctOf conj . 

Rule conjTypeR
if x rdf:type conj
and cls conjunctOf conj
and conj is not a SubConjunction
then
	x rdf:type cls.

// Do we need the transitive rules, Transitive1 needs to be modified is needed?
// Rule Transitive1 
// if cls1 rdfs:subClassOf cls2
// and cls2 rdfs:subClassOf cls3
// then cls1 rdfs:subClassOf cls3.
 
 Rule Transitive2  
if inst is a cls
   and cls is a type of cls2
then inst is a cls2.

Rule varNameR
if 	    x is a Variable
	and x identifier id
	and xn is strafter(strbefore(strafter(strafter(id,"::"),"::"),"::"),"\\\\.")
then x varName xn.

Rule explicitVarR
if	    x is a Variable
	and from_source of metadata of x is true
then x is an ExplicitVariable.

Rule sameVarR
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block
	and x2 inBlock block
	and x1 != x2
	and varName of x1 == varName of x2
then x1 sameVar x2.

Rule sameVarR2
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block1
	and x2 inBlock block2
	and block2 parent block1
	and varName of x1 == varName of x2
then    x1 sameVar x2
	and x2 sameVar x1.
	
Rule sameVarInterfaceR
if 		x1 is a Variable
	and x2 is a Variable
	and edge inputs x1
	and edge outputs x2
	and edge function fun
	and fun ftype "INTERFACE"
	and x1 != x2
	and varName of x1 == varName of x2
then    x1 sameVar x2
    and x2 sameVar x1.	

Rule sameVarStructureR1
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "PACK"
	and e2 inputs x2
	and x1 != x2
	and varName of x1 == varName of x2
then x1 sameVar x2.

Rule sameVarStructureR2
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and e1 outputs struct1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "EXTRACT"
	and e2 outputs x2
	and e2 inputs struct2
	and varName of struct1 == varName of struct2
	and x1 != x2
	and varName of x1 == varName of x2
then    x1 sameVar x2
    and x2 sameVar x1.

Rule structureVariableR
if	edge function fun
	and fun ftype "PACK"
	and edge outputs var
then var is a Structure.

Rule loopBlockR
if	 node sg_type "LoopContainer"
then node is a LoopBlock.
	
Rule funcBlockR
if	 node sg_type "FuncContainer"
then node is a FunctionBlock.
	
Rule nestedBlockR
if		node is a SubGraph
	and node parent par
then node is a NestedBlock.
	
Rule varInBlockR
if		var is a Variable
	and b is a SubGraph
	and b nodes var
then var inBlock b.

Rule lineEndR
if		x metadata md
	and noValue(md,line_end)
	and md line_begin lb
then md line_end lb.

Rule literalInitializedR1
if		edge function f
	and f ftype "LITERAL"
	and edge outputs var
	and var is an ExplicitVariable
then  var is a LiteralInitialized .

//Find parameter argument pairs.
Rule argParamPairR
if	edge is a HyperEdge
	and edge function fun
	and fun ftype "INTERFACE"
	and grph nodes fun
	and sg_type of grph != "LoopContainer"
	and edge inputList inList
	and edge outputList outList
	and arg is a Variable
	and param is a ExplicitVariable
	and _idx is index of arg in inList
	and _idx is index of param in outList
then
	there exists an ArgParamPair pair
	and edge argumentParameterPair pair
	and pair parameter param
	and pair argument arg
. 

Rule lhsR1 
if	 var is LiteralInitialized
then var is a LHS.

Rule lhsR2
if		edge is a HyperEdge
   	and edge outputs var
   	and var is an ExplicitVariable
   	and edge function fun
   	and fun ftype "ASSIGN"
then 
	var is a LHS.

//a parameter assigned an argument is also a LHS
Rule lhsR3
if	pair parameter param
	and pair argument arg
then
	param is a LHS.
	
Rule lhsR4 //LHS of function call 
if		edge is a HyperEdge
   	and edge outputs var  //   	and from_source of metadata of var is true //only look at explicit vars
   	and var is an ExplicitVariable
   	and edge function fun
   	and fun ftype "INTERFACE"
   	and edge inputs ret
   	and ret varName "RETURN_VAL"
then 
	var is a LHS.
	
Rule MultiplicationR
if	    nd is an ExpNode
	and nd operator "Mult"
	and nd children clist
	and mxx is an ExpNode
	and index of mxx in clist is idx
then    nd is a Multiplication
	and nd multiplicand mxx.

Rule SummationR
if	    nd is an ExpNode
	and nd operator "Add"
	and nd children clist
	and mxx is an ExpNode
	and index of mxx in clist is idx
then    nd is a Summation
	and nd summand mxx.

Rule SubtractionR
if	    nd is an ExpNode
	and nd operator "Sub"
	and nd children clist
	and m is element 0 of clist
	and s is element 1 of clist
then    nd is a Subtraction
	and nd minuend m
	and nd subtrahend s.

// I think we can drop "Stage 1" from the "notConstant" rules and reduce other stage numbers by 1.
Stage 1 Rule notConstantR1
if		var1 is a LHS
	and var2 is a LHS 
	and var1 sameVar var2
	and edge inputs var1
	and edge outputs var2
	and edge function fun
then
	var1 is a NotConstant
	and var2 is a NotConstant.

Stage 1 Rule notConstantR2
if		var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a LoopBlock
then var is a NotConstant.

Stage 1 Rule notConstantR3
if	pair parameter param
	and pair argument arg
	and arg is a NotConstant
then
	param is a NotConstant.

Stage 1 Rule notConstantR4
if	var1 is an ExplicitVariable
	and var2 is a NotConstant
	and var1 sameVar var2
	and gph nodes var1
	and gph nodes var2
then
	var1 is a NotConstant.
	
Stage 1 Rule notConstantR5
if	edge function fun
	and edge inputs var1
	and edge outputs var2
	and var1 sameVar var2
	and grph nodes fun
	and grph sg_type "LoopContainer"
	and var2 is a NotConstant
then
	var1 is a NotConstant.	
	
Stage 1 Rule notConstantR6
if		edge function f
	and f ftype "ASSIGN"
	and edge outputs var
	and var is an ExplicitVariable
	and edge inputs varI
	and varI is a NotConstant
then
	var is a NotConstant.
	
Stage 2 Rule constantR
if		var is a ExplicitVariable
	and var is not a NotConstant
then var is a Constant.

// this still uses element 0 etc., can we re-write it?
Rule ErrorSignalCandidateR
if 		fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2 
	and edge outputs var
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and ms_et grfn_uid ms
    and fun lambda expr0
    and expr is strafter(expr0,":")
then    
	    var is an ErrorSignalCandidate
	and rs is a ReferenceSignalCandidate 
	and ms is a MeasurementSignalCandidate
	and var referenceSignalCandidate rs  
	and var measurementSignalCandidate ms
	and var semanticExpression expr.

Stage 2 Rule ErrorSignalR  // turning a ErrorSignalCandidate into a ErrorSignal
if es1 is an ErrorSignalCandidate
   and es2 is an ErrorSignalCandidate
   and md1 is metadata of es1
   and md2 is metadata of es2
   and md1 line_begin l1
   and md2 line_begin l2
   and l1 < l2
   and rs is referenceSignalCandidate of es1
   and ms is measurementSignalCandidate of es1
   and rs2 is referenceSignalCandidate of es2
   and ms2 is measurementSignalCandidate of es2
then   es1 is an ErrorSignal
   and rs is referenceSignal of es1
   and ms is measurementSignal of es1
   and rs is a ReferenceSignal
   and ms is a MeasurementSignal
   and es2 is a DerivativeCandidate
   and rs2 is errorCandidate of es2
   and ms2 is prevErrorCandidate of es2.

Stage 2 Rule ErrorSignalR2 
if     countMatches(es, rdf:type, ErrorSignalCandidate) = 1 
   and es1 is an ErrorSignalCandidate
   and rs is referenceSignalCandidate of es1
   and ms is measurementSignalCandidate of es1   
then   es1 is an ErrorSignal
   and rs is a ReferenceSignal
   and ms is a MeasurementSignal.

// we need to check that we have "error_last = error" however the json / sadl representation does not seem to be correct   
Stage 2 Rule DerivativeR 
if     es is a ErrorSignal
   and der is a DerivativeCandidate
   and ec is errorCandidate of der
   and pec is prevErrorCandidate of der
   and ec is a ErrorSignal
then   der is a Derivative
   and pec is a PrevError.

Stage 2 Rule IntegratorCandidateR
if      x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
    and n1 is a Summation // one child should be Mult and one should be what is in LHS in our example
	and n1 summand c1
	and n1 summand c2
    and c2 var_name out_name // so LHS is repeated in the RHS    
    and c1 is a Multiplication
    and c1 multiplicand cc2   
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS
then out is an Integrator.    

// no multiplier
Stage 2 Rule IntegratorCandidateR2 // make it more robust
if      x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
    and n1 is a Summation // one child should be Mult and one should be what is in LHS in our example
	and n1 summand c1
	and n1 summand c2
    and c2 var_name out_name // so LHS is repeated in the RHS    
    and x varName error_signal_name
    and c1 var_name error_signal_name  // so ErrorSignal present in RHS
then out is an Integrator.    

// This rule is still dependent on a particular order in the subtraction
Stage 2 Rule IntegratorTypoR
if      x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
	and n1 is a Subtraction
	and n1 minuend c2
	and n1 subtrahend c1 
    and c2 var_name out_name // so LHS is repeated in the RHS    
    and c1 is a Multiplication
    and c1 multiplicand cc2    
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS
then out is an IntegratorTypo.    

Stage 3 Rule PropExpNodeR 
if      m is a Multiplication
	and m multiplicand err_var
	and err_var grfn_uid err
	and err is an ErrorSignal
	and m multiplicand kp_var
	and kp_var grfn_uid kp_cand
	and kp is a Constant
	and kp is not an ErrorSignal //hence this is Stage 3
	and varName of kp == varName of kp_cand
	and err != kp // I THINK I NEED TO SAY varName NOT SAME!!!!!!!!!!
then    m is a PropExpNode //ConstTimesError
    and m proportionalConstant kp //kp_cand
    and m errorVariable err
//     and kp_cand is a ProportionalConstant //once we line up parameters and arguments, kp_cand should replace kp here
    and kp is a ProportionalConstant.

//Ask: select distinct err kp errid kpid
//where
//	nd is a PropExpNode
//	and nd proportionalConstant kp
//	and kp varName kpn
//	and kp identifier kpid
//	and nd errorVariable err
//	and err varName errn
//	and err identifier errid
//.


Stage 2 Rule IntExpNodeR // matches constant * integrator value
if      m is a Multiplication
	and m multiplicand int_var
	and int_var grfn_uid int_cand
	and int_cand is an Integrator
	and m multiplicand ki_var
	and ki_var grfn_uid ki_cand
	and ki is a Constant
	and varName of ki == varName of ki_cand
	and varName of int_cand != varName of ki
then     m is a IntExpNode 
    and m integratorConstant ki 
    and ki is a IntegratorConstant
    and m integratorVariable int_cand.

Stage 2 Rule DervExpNodeR
if      m is a Multiplication
	and m multiplicand derv_var
	and derv_var grfn_uid derv_cand
	and derv_cand is an Derivative
	and m multiplicand kd_var
	and kd_var grfn_uid kd_cand
	and kd is a Constant
	and varName of kd == varName of kd_cand
	and varName of derv_cand != varName of kd
then    m is a DervExpNode 
    and m derivativeConstant kd //ki_cand
//     and ki_cand is a IntegratorConstant //once we line up parameters and arguments, ki_cand should replace ki
    and kd is a DerivativeConstant
    and m derivativeVariable derv_cand.
	
Stage 2 Rule ControllerNameR
if 	    sg nodes exp
	and exp is a Controller
	and sg is a SubGraph
 	and sg nodes somenode
 	and somenode identifier id	
 	and exp_name is strbefore(strafter(id,"::"),"::")
 then exp constructName exp_name. 	

Stage 2 Rule ControllerMetadataR
if 	sg is a SubGraph
	and sg nodes pic
	and pic is a Controller
	and sg metadata md
 	and md line_begin lbeg
 	and md line_end lend
then    pic linebegin lbeg
	and pic lineend lend.


Stage 3 Rule P-ControllerCandidateR
if  	et is an ExpressionTree
	and et nodes exp
	and exp is a PropExpNode
	and exp is a Multiplication 
	and exp multiplicand m1
	and exp multiplicand m2
then et is a P-ControllerCandidate.

Stage 3 Rule PI-ControllerCandidateR
if  	et is a P-ControllerCandidate
	and et nodes exp
	and exp is a Summation 
	and exp summand m1
	and exp summand m2
	and m1 is a PropExpNode 
	and m1 proportionalConstant kp
	and m2 is a IntExpNode 
	and m2 integratorConstant ki
then et is a PI-ControllerCandidate.

Stage 3 Rule PD-ControllerCandidateR
if 		et is a P-ControllerCandidate
	and et nodes exp
	and exp is a Summation 
	and exp summand m1
	and exp summand m2
	and m1 is a PropExpNode
	and m1 proportionalConstant kp
	and m2 is a DervExpNode
	and m2 derivativeConstant kd
then et is a PD-ControllerCandidate.


Stage 3 Rule PID-ControllerR
if     et is an PI-ControllerCandidate
   and et nodes n1
   and n1 is a DervExpNode
then et is a PID-Controller.


Stage 4 Rule P-ControllerR
if		et is a P-ControllerCandidate
	and noValue(et1,rdf:type,PI-ControllerCandidate)
	and noValue(et1,rdf:type,PD-ControllerCandidate)
	and noValue(et1,rdf:type,PID-Controller)
then
	et is a P-Controller.

Stage 4 Rule PI-ControllerR
if	et is a PI-ControllerCandidate
	and noValue(et1,rdf:type,PID-Controller)
then
	et is a PI-Controller.

Stage 4 Rule PD-ControllerR
if	et is a PD-ControllerCandidate
	and noValue(et1,rdf:type,PID-Controller)
then
	et is a PD-Controller.
	
	
//Write: data{
//Ask: "select distinct ?Name ?AnnotationType ?Description ?Loc_start ?Loc_end ?Qual_name ?Equation    
//where {
//{ ?AnnotationType <rdfs:subClassOf>* <ControllerConstruct>
//. ?x a ?AnnotationType 
//.  filter not exists {
//       ?C <rdfs:subClassOf> ?AnnotationType.
//       ?x a ?C.
//     }
//. ?x <varName> ?Name
//. ?AnnotationType <description> ?Description
//. ?x <identifier> ?Qual_name
//. ?x <metadata> ?md
//. OPTIONAL{?md <line_begin> ?Loc_start} 
//. OPTIONAL{?md <line_end> ?Loc_end}
//. OPTIONAL{?x <semanticExpression> ?Equation} 
//} union {
//?sg <rdf:type> <SubGraph>
//. ?sg <nodes> ?x
//. ?x <rdf:type> <Controller>
//. ?x <constructName> ?Name
//#. ?x <rdfs:subClassOf> <Controller>
//. ?x a ?AnnotationType
//.  filter not exists {
//       ?C <rdfs:subClassOf> ?AnnotationType.
//       ?x a ?C.
//     }
//. FILTER(regex(str(?AnnotationType),'Controller')) # I need this but can I avoid it
//. OPTIONAL{?x <linebegin> ?Loc_start.}
//. OPTIONAL{?x <lineend> ?Loc_end.}
//. OPTIONAL{?AnnotationType <description> ?Description}
//. OPTIONAL{?x <lambda> ?Eq . LET(?Equation := replace(str(?Eq),'^.*: ',''))}
//} 
//} order by ?AnnotationType ?Name".     
//}to "SemAnnotation.csv".   

