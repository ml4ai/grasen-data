 uri "http://sadl.org/SemAnnotator.sadl" alias semannotator.
 
import "http://sadl.org/GrFNExtractionModel.sadl" as grfnem.
 
// select the C code file for processing
import "http://aske.ge.com/GE_simple_PI_controller_combined".
//import "http://aske.ge.com/GE_simple_PI_controller_inline".
//import "http://aske.ge.com/GE_simple_PI_controller_typo_combined".

//import "http://aske.ge.com/PID".
//import "http://aske.ge.com/GE_simple_PI_controller_saturation".

ControllerConstruct is a class
	described by constructName with values of type string
	described by linebegin with values of type int
	described by lineend with values of type int
	. 

LoopBlock is a type of SubGraph.
FunctionBlock is a type of SubGraph.
NestedBlock is a type of SubGraph.
LHS (note "a var that appears on the LHS of an assignment") is a type of Variable.

sameVar describes Variable with values of type Variable.
varName describes Variable with values of type string.
inBlock describes Variable with values of type SubGraph.
LiteralInitialized is a type of Variable.
NotConstant is a type of Variable.
Constant is a type of Variable. 
ExplicitVariable is a type of Variable.
Structure is a type of Variable.

ErrorSignal is a type of Variable
	described by referenceSignal with a single value of type ReferenceSignal
	described by measurementSignal with a single value of type MeasurementSignal.
ReferenceSignal is a type of Variable.
MeasurementSignal is a type of Variable.

Increment is a type of Variable. // the only assignment to it is of the form x = x +/-/* y
Counter is a type of Variable. // It is an Increment where y is a constant value or a literal
Accumulator is a type of Variable. // It is an Increment where y is not a constant or a literal
Integrator is a type of Variable. // It is an Accumulator where y is proportional to (ref signal - measured signal)
PI-Controller is a type of Node //Do I want it as node??????
	described by 
semanticExpression describes Variable with a single value of type string.

Constant is a type of ControllerConstruct.
description of Constant is "This is a constant.".
ErrorSignal is a type of ControllerConstruct.
description of ErrorSignal is "This is an error signal candidate.".
ReferenceSignal is a type of ControllerConstruct.
description of ReferenceSignal is "This is a reference signal candidate.".
MeasurementSignal is a type of ControllerConstruct.
description of MeasurementSignal is "This is a measurement signal candidate.".
Integrator is a type of ControllerConstruct.
description of Integrator is "This is an Integrator.".
IntegratorConstant is a type of Constant.
description of IntegratorConstant is "This is the constant multiplier for the Integrator.".
ProportionalConstant is a type of Constant.
description of ProportionalConstant is "This is the constant multiplier for the Proportional term.".
PI-Controller is a type of ControllerConstruct.
description of PI-Controller is "This is a PI Controller.".

//multiplication describes ExpressionTree with values of type ExpNode.


//Stage 6 Rule instanceOfSubclassR
//if		x is a SubClass
//	and SubClass is a type of SuperClass
//then
//	x is a SuperClass.

Rule varNameR
if 		x is a Variable
	and x identifier id
	and xn is strafter(strbefore(strafter(strafter(id,"::"),"::"),"::"),"\\\\.")
then
	x varName xn.


Rule explicitVarR
if		x is a Variable
	and from_source of metadata of x is true
then
	x is an ExplicitVariable.

//Ask: select distinct vn where x is an ExplicitVariable and x varName vn.
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <ExplicitVariable>.
// ?var <varName> ?vn.
//}".

////Ask: "select count(concat(str(?var1),str(?var2))) 
//Ask: "select ?id1 ?id2 
//where{
// ?var2 a <ExplicitVariable>.
// ?var1 <sameVar> ?var2.
// ?var1 <identifier> ?id1.
// ?var2 <identifier> ?id2.
// filter(str(?var1) < str(?var2))
//}".


Rule sameVarR
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block
	and x2 inBlock block
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2.

Rule sameVarR2
if 		x1 is a Variable
	and x2 is a Variable
	and x1 inBlock block1
	and x2 inBlock block2
	and block2 parent block1
	and varName of x1 == varName of x2
then
	x1 sameVar x2
	and x2 sameVar x1
	.

	
Rule sameVarInterfaceR
if 		x1 is a Variable
	and x2 is a Variable
	and edge inputs x1
	and edge outputs x2
	and edge function fun
	and fun ftype "INTERFACE"
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2
and x2 sameVar x1.	

sameStruct describes Variable with values of type Variable.

Rule sameVarStructureR1
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "PACK"
	and e2 inputs x2
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2
//and	x1 sameStruct x2
	.

Rule sameVarStructureR2
if 		x1 is a Variable
	and e1 function fun1
	and fun1 ftype "PACK"
	and e1 inputs x1
	and e1 outputs struct1
	and x2 is a Variable
	and e2 function fun2
	and fun2 ftype "EXTRACT"
	and e2 outputs x2
	and e2 inputs struct2
	and varName of struct1 == varName of struct2
	and x1 != x2
	and varName of x1 == varName of x2
then
	x1 sameVar x2
and x2 sameVar x1
//and	x1 sameStruct x2
	.

//Ask: select id1 id2 where var1 sameStruct var2 and var1 identifier id1 and var2 identifier id2.
//Ask: "select count(concat(str(?id1),str(?id2)))
//where{
// ?var1 <sameStruct> ?var2.
// ?var1 <identifier> ?id1.
// ?var2 <identifier> ?id2.
//}".

Rule structureVariable
if	edge function fun
	and fun ftype "PACK"
	and edge outputs var
then
	var is a Structure.
	
//Ask: select vn id where var is a Structure and var varName vn and var identifier id.

Rule loopBlockR
if	 node sg_type "LoopContainer"
then node is a LoopBlock.
	
Rule funcBlockR
if	 node sg_type "FuncContainer"
then node is a FunctionBlock.
	
Rule nestedBlockR
if		node is a SubGraph
	and node parent par
then 
	node is a NestedBlock.
	
Rule varInBlockR
if		var is a Variable
	and b is a SubGraph
	and b nodes var
then
	var inBlock b.
	
//Ask: select distinct vn bt where var inBlock b and var varName vn and b sg_type bt.

Rule lineEndR
if		x metadata md
	and noValue(md,line_end)
	and md line_begin lb
then
	md line_end lb.


Rule lhsR 
if		edge is a HyperEdge
   	and edge outputs var
   	and from_source of metadata of var is true //only look at explicit vars
   	and edge function fun
   	and ftype of fun != "INTERFACE"
   	and ftype of fun != "PACK"
then 
	var is a LHS.
	
//Ask: select vn vid where var is a LHS and var varName vn and var identifier vid.
	
Rule literalInitializedR1
if		edge function f
	and f ftype "LITERAL"
	and edge outputs var
	and var is an ExplicitVariable
then 
	var is a LiteralInitialized .

Rule literalInitializedR2
if	var1 is an ExplicitVariable
	and var2 is LiteralInitialized
	and var1 sameVar var2
then 
	var1 is a LiteralInitialized .

	
//Ask: select distinct vn vid where var varName vn and var is a LiteralInitialized and var identifier vid.
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <LiteralInitialized>.
//# ?var <identifier> ?vid.
//?var <varName> ?vn.
//}".


Stage 1 
Rule notConstantR1
if		var1 is a LHS
	and var2 is a LHS
	and var1 sameVar var2
then
	var1 is a NotConstant.

Stage 1 
Rule notConstantR2
if		var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a LoopBlock
then
	var is a NotConstant.

Stage 1 
Rule notConstantR2A
if		var is a LHS
	and var is not a LiteralInitialized 
	and var inBlock block
	and block is a NestedBlock
then
	var is a NotConstant.

//Ask: select var,vid
//where
//	fun is an Function
//	and fun ftype "INTERFACE"
//	and fun nodes argument
//	and argument grfn_uid arg_expnode
//	and edge function fun
//	and edge inputs arg_expnode
//	and edge outputs 
	



//Ask: "select ?vn ?var ?block 
//where{
//	?var a <LHS>.
//	 filter not exists {?var a <LiteralInitialized>}. 
//	 ?var <inBlock> ?block.
//	 ?block a <NestedBlock>.
//	?var <varName> ?vn.
//}".

//Ask: select var vname
//where
//	var is a LHS
//	and var inBlock block
//	and block is a NestedBlock
//	and var varName vname
//	and var is not a LiteralInitialized 
//.

//Stage 2
////Stage 1 
//Rule notConstantR3
//if		var1 is a NotConstant
//	and var1 sameVar var2
//	and var2 is an ExplicitVariable
//then
//	var2 is a NotConstant.

//Ask: select distinct vn vid where var is a NotConstant and var varName vn and var identifier vid.
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <NotConstant>.
// ?var <varName> ?vn.
//}".


//Ask: select distinct vn vid where var is a Variable and var varName vn and var identifier vid and var is not a NotConstant.

//Stage 3 
Stage 2
Rule constantR
if		var is a LHS
	and var is a ExplicitVariable
	and var is not a NotConstant
then
	var is a Constant.

// We may need this for future rules (not queries). It generates more constants.
//Stage 2
//Rule constantR2
//if	var1 is a LHS
//	and var1 is not a NotConstant
//	and var1 sameVar var2
//then
//	var2 is a Constant.


//Ask: select distinct vn vid var where var is a Constant and var varName vn and var identifier vid . 
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <Constant>.
// ?var <varName> ?vn.
//}".


//Ask: select distinct var vn vid where var is a ExplicitVariable and var varName vn and var identifier vid and var is a Constant . 
//Ask: select distinct vn vid where var is a ExplicitVariable and var varName vn and var identifier vid and var is a NotConstant.

//Ask: select distinct vn where var is a Variable and var varName vn and var identifier vid and var is a Constant.

Rule ErrorSignalCandidate
if 		fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2 
	and edge outputs var
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and ms_et grfn_uid ms
    and fun lambda expr0
    and expr is strafter(expr0,":")
then
		var is an ErrorSignal
	and rs is a ReferenceSignal 
	and ms is a MeasurementSignal
	and var referenceSignal rs
	and var measurementSignal ms
	and var semanticExpression expr
.

//Doesn't work because edge has many inputs/outputs for complex expression
Rule ReferenceSignalCandidate  // works if the error computation is inlined
if 	fun is an ExpressionTree
	and fun nodes op
	and op operator "Sub"
	and op children clist
	and edge function fun 
	and countMatches(edge,inputs) = 2
	and rs_et is element 0 of clist
	and ms_et is element 1 of clist
	and rs_et grfn_uid rs
	and ms_et grfn_uid ms 
then rs is a ReferenceSignal 
	and ms is a MeasurementSignal
.


//Ask: select distinct vn where var is a ErrorSignal and var varName vn.
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <ErrorSignal>.
// ?var <varName> ?vn.
//}".
//
//Ask: select distinct vn where var is a ReferenceSignal and var varName vn.
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <ReferenceSignal>.
// ?var <varName> ?vn.
//}".
//
//Ask: select distinct vn where var is a MeasurementSignal and var varName vn.
//Ask: "select count(distinct ?vn) 
//where{
// ?var a <MeasurementSignal>.
// ?var <varName> ?vn.
//}".



Stage 2 
Rule IntegratorCandidate
if  x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later
    and n1 is a Summation // one child should be Mult and one should be what is in LHS in our example
	and n1 summand c1
	and n1 summand c2
    and c2 var_name out_name // so LHS is repeated in the RHS
    
    and c1 is a Multiplication
    and c1 multiplicand cc2
    
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS

then //print("x on both sides of = ", out_name) and
     out is an Integrator.    

//Ask: select distinct vn vid where var is a Integrator and var varName vn and var identifier vid.


IntegratorBug is a type of Variable.


// This rule is still dependent on a particular order in the subtraction
Stage 2 
Rule IntegratorCandidateBug
if  x is an ErrorSignal // will be using it later, this will "sequence" this rule to fire after we have identified ErrorSignal
    and fun is an Function
    and fun ftype "ASSIGN"
    and he function fun
    and he is a HyperEdge
    and he outputs out
    and out varName out_name
    and he inputs in1
    and in1 varName out_name
    and fun nodes n1  // now parse through the ExpressionTree, want n1 to be the "root"
    and expNode is an ExpNode
    and expNode exp_node_type "OPERATOR"
    and expNode children clist
    and n1 is element 0 of clist   // not checking if there is only 1 element in clist - do that later

	and n1 is a Subtraction
	and n1 minuend c2
	and n1 subtrahend c1 
    and c2 var_name out_name // so LHS is repeated in the RHS
    
    and c1 is a Multiplication
    and c1 multiplicand cc2
    
    and x varName error_signal_name
    and cc2 var_name error_signal_name  // so ErrorSignal present in RHS

then //print("x on both sides of = ", out_name) and
     out is an IntegratorBug.    


//Ask: select distinct vn vid where var is a IntegratorBug and var varName vn and var identifier vid.

Multiplication is a type of ExpNode
	described by multiplicand with values of type ExpNode.

Rule MultiplicationR
if	nd is an ExpNode
	and nd operator "Mult"
	and nd children clist
	and mxx is an ExpNode
	and index of mxx in clist is idx
then
	nd is a Multiplication
	and nd multiplicand mxx
	.

//Ask: select nd m mn where nd multiplicand m and m var_name mn.

Summation is a type of ExpNode
	described by summand with values of type ExpNode.

Rule SummationR
if	nd is an ExpNode
	and nd operator "Add"
	and nd children clist
	and mxx is an ExpNode
	and index of mxx in clist is idx
then
	nd is a Summation
	and nd summand mxx
.

//Ask: select nd m mn where nd summand m and m var_name mn.


Subtraction is a type of ExpNode
	described by minuend with values of type ExpNode
	described by subtrahend with values of type ExpNode.

Rule SubtractionR
if	nd is an ExpNode
	and nd operator "Sub"
	and nd children clist
	and m is element 0 of clist
	and s is element 1 of clist
then
	nd is a Subtraction
	and nd minuend m
	and nd subtrahend s
.

//Ask: select nd m s where nd minuend m and nd subtrahend s.


ConstTimesError is a type of ExpNode.
errorVariable describes ExpNode with values of type ErrorSignal.
proportionalConstant describes ExpNode with values of type Constant.

Stage 2
Rule ConstTimesErrorR
if  m is a Multiplication
	and m multiplicand err_var
	and err_var grfn_uid err
	and err is an ErrorSignal
	and m multiplicand kp_var
	and kp_var grfn_uid kp_cand
	and kp is a Constant
	and varName of kp == varName of kp_cand
then 
     m is a ConstTimesError
     and m proportionalConstant kp //kp_cand
     and m errorVariable err
//     and kp_cand is a ProportionalConstant //once we line up parameters and arguments, kp_cand should replace kp here
     and kp is a ProportionalConstant
.

//Ask: select distinct errid kpid
//where
//	nd is a ConstTimesError
//	and nd proportionalConstant kp
//	and kp varName kpn
//	and kp identifier kpid
//	and nd errorVariable err
//	and err varName errn
//	and err identifier errid
//.



ConstTimesIntegrator is a type of ExpNode.
integratorVariable describes ExpNode with values of type Integrator.
integratorConstant describes ExpNode with values of type Constant.

Stage 2
Rule ConstTimesIntegratorR
if  m is a Multiplication
	and m multiplicand int_var
	and int_var grfn_uid int_cand
	and int_cand is an Integrator
	and m multiplicand ki_var
	and ki_var grfn_uid ki_cand
	and ki is a Constant
	and varName of ki == varName of ki_cand
then 
     m is a ConstTimesIntegrator 
     and m integratorConstant ki //ki_cand
//     and ki_cand is a IntegratorConstant //once we line up parameters and arguments, ki_cand should replace ki
     and ki is a IntegratorConstant
     and m integratorVariable int_cand
.

//Ask: select distinct intid kiid
//where
//	nd is a ConstTimesIntegrator
//	and nd integratorConstant ki
//	and ki varName kin
//	and ki identifier kiid
//	and nd integratorVariable intvar
//	and intvar varName intn
//	and intvar identifier intid
//.

//This definition works for any expression ordering
Stage 2
Rule PI-ControllerCandidate
if  et is an ExpressionTree
	and et nodes exp
	and exp is a Summation 
	and exp summand m1
	and exp summand m2
	and m1 is a ConstTimesError
	and m1 proportionalConstant kp
	and m2 is a ConstTimesIntegrator
	and m2 integratorConstant ki
then
    et is a PI-Controller // instead of exp have the entire module
	and et proportionalConstant kp
	and et integratorConstant ki
.

//Ask: select distinct kiid kpid
//where
//	et is a PI-Controller
//	and et integratorConstant ki
//	and ki varName kin
//	and ki identifier kiid
//	and et proportionalConstant kp
//	and kp varName kpn
//	and kp identifier kpid
//.

//Ask: select distinct var where var is a PI-Controller.
//Ask: "select count(distinct ?var) 
//where{
// ?var a <PI-Controller>.
//}".



Stage 2
Rule PI-ControllerName
if 	sg is a SubGraph
	and sg nodes et
	and et is a PI-Controller
 	and sg nodes somenode
 	and somenode identifier id	
 	and exp_name is strbefore(strafter(id,"::"),"::")
 then
 	et constructName exp_name
. 	
//Ask: select distinct pic_name where pic is a PI-Controller and pic constructName pic_name.


Stage 2
Rule PI-ControllerMetadata
if 	sg is a SubGraph
	and sg nodes pic
	and pic is a PI-Controller
	and sg metadata md
 	and md line_begin lbeg
 	and md line_end lend
then 
	pic linebegin lbeg
	and pic lineend lend
.


//Ask: select distinct pname beg end
//where
//	p is a PI-Controller
//	and p constructName pname
//	and p metadata pmd
////	and pmd line_begin beg
////	and pmd line_end end
//	and p linebegin beg
//	and p lineend end
//	.



//Write: data{
Ask: "select distinct ?Name ?AnnotationType ?Description ?Loc_start ?Loc_end ?Qual_name ?Equation    
where {
{  ?AnnotationType <rdfs:subClassOf>* <ControllerConstruct>
. ?x a ?AnnotationType 
.  filter not exists {
       ?C <rdfs:subClassOf> ?AnnotationType.
       ?x a ?C.
     }
. ?x <varName> ?Name
. ?AnnotationType <description> ?Description
. ?x <identifier> ?Qual_name
. ?x <metadata> ?md
. OPTIONAL{?md <line_begin> ?Loc_start} 
. OPTIONAL{?md <line_end> ?Loc_end}
. OPTIONAL{?x <semanticExpression> ?Equation} 
} union {
 ?x a <PI-Controller>
. ?x a ?AnnotationType
. ?AnnotationType <rdfs:subClassOf> <ControllerConstruct>
. ?x <constructName> ?Name
. OPTIONAL{?x <linebegin> ?Loc_start.}
. OPTIONAL{?x <lineend> ?Loc_end.}
. OPTIONAL{?AnnotationType <description> ?Description}
. OPTIONAL{?x <lambda> ?Equation} 
}
} order by ?AnnotationType ?Name".     
//}to "SemAnnotation.csv".

